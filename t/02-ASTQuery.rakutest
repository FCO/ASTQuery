use experimental :rakuast;
use ASTQuery;
use ASTQuery::Matcher;
use Test;

ok &ast-matcher;
ok &ast-query;

for %(
	"RakuAST::Node" => %(
		meth  => "classes",
		value => Array[ASTQuery::Matcher::ASTClass(Any)].new("RakuAST::Node"),
	),
	".conditional" => %(
		meth  => "groups",
		value => Array[ASTQuery::Matcher::ASTGroup(Any)].new("conditional"),
	),
	"#blablabla" => %(
		meth  => "ids",
		value => ["blablabla", ],
	),
	"[attribute]" => %(
		meth  => "atts",
		value => %(attribute => True),
	),
	"RakuAST::Node > RakuAST::Node" => %(
		meth  => "child",
		value => ast-matcher("RakuAST::Node"),
	),
	"RakuAST::Node >> RakuAST::Node" => %(
		meth  => "gchild",
		value => ast-matcher("RakuAST::Node"),
	),
	"RakuAST::Node >>> RakuAST::Node" => %(
		meth  => "descendant",
		value => ast-matcher("RakuAST::Node"),
	),
	"RakuAST::Node < RakuAST::Node" => %(
		meth  => "parent",
		value => ast-matcher("RakuAST::Node"),
	),
	"RakuAST::Node << RakuAST::Node" => %(
		meth  => "gparent",
		value => ast-matcher("RakuAST::Node"),
	),
	"RakuAST::Node <<< RakuAST::Node" => %(
		meth  => "ascendant",
		value => ast-matcher("RakuAST::Node"),
	),
	'$name' => %(
		meth  => "name",
		value => "name",
	),
).kv -> $selector, %h (Str :$meth, :$value) {
	my $matcher = ast-matcher($selector);
	isa-ok $matcher, ASTQuery::Matcher, "isa-ok: " ~ %h.gist;
	is-deeply $matcher."$meth"(), $value, "is-deeply: " ~ %h.gist;
}

for %(
	Q|42| => %(
		matcher => Q|RakuAST::IntLiteral|,
		list    => [
			RakuAST::IntLiteral.new(42)
		],
		hash    => %(),
	),
	Q|42, 13, 3| => %(
		matcher => Q|RakuAST::IntLiteral|,
		list    => [
			RakuAST::IntLiteral.new(42),
			RakuAST::IntLiteral.new(13),
			RakuAST::IntLiteral.new(3),
		],
		hash    => %(),
	),
	Q|42, 13, 3| => %(
		matcher => Q|.int|,
		list    => [
			RakuAST::IntLiteral.new(42),
			RakuAST::IntLiteral.new(13),
			RakuAST::IntLiteral.new(3),
		],
		hash    => %(),
	),
	Q|42, 13, 3| => %(
		matcher => Q|#42|,
		list    => [
			RakuAST::IntLiteral.new(42),
		],
		hash    => %(),
	),
	Q|42, 13, 3| => %(
		matcher => Q|[value=42]|,
		list    => [
			RakuAST::IntLiteral.new(42),
		],
		hash    => %(),
	),
	Q|42, 13, 3| => %(
		matcher => Q|.int$test|,
		list    => [
			RakuAST::IntLiteral.new(42),
			RakuAST::IntLiteral.new(13),
			RakuAST::IntLiteral.new(3),
		],
		hash    => %(
			:test[
				RakuAST::IntLiteral.new(42),
				RakuAST::IntLiteral.new(13),
				RakuAST::IntLiteral.new(3),
			]
		),
	),
	Q|say 42| => %(
		matcher => Q|.call >> .int$integer|,
		list    => [
			RakuAST::Call::Name::WithoutParentheses.new(
				name => RakuAST::Name.from-identifier("say"),
				args => RakuAST::ArgList.new(
					RakuAST::IntLiteral.new(42),
				)
			)
		],
		hash    => %(
			:integer( RakuAST::IntLiteral.new(42) )
		),
	),
).kv -> Str $ast, % (Str :$matcher, :@list, :%hash) {
	diag "$ast ~~ $matcher";
	is-deeply ast-query($ast.AST, ast-matcher $matcher),
		ASTQuery::Match.new(
			:@list,
			:%hash,
			:matcher(ast-matcher $matcher),
			:ast($ast.AST),
		)
	;
	is-deeply ast-query($ast.AST, $matcher),
		ASTQuery::Match.new(
			:@list,
			:%hash,
			:matcher(ast-matcher $matcher),
			:ast($ast.AST),
		)
	;
}

# --- ergonomic group aliases and new groups ---
{
	my $ast = q{
		my $x = 1;
		$x = 2;
		say 1 + 2;
	}.AST;

	my $ops = $ast.&ast-query('.operator');
	ok $ops.list.grep({ .^name ~~ /Infix|Prefix|Postfix/ }).elems >= 1,
		'operator group finds operator nodes';

	my $apply_ops = $ast.&ast-query('.apply-operator');
	ok $apply_ops.list.grep({ .^name ~~ /Apply(Infix|ListInfix|Postfix)|Ternary/ }).elems >= 1,
		'apply-operator group finds apply nodes';

	my $vars = $ast.&ast-query('.variable-usage');
	ok $vars.list.grep({ .^name ~~ /Var/ }).elems >= 1,
		'variable-usage matches Var nodes';

	my $decls = $ast.&ast-query('.variable-declaration');
	ok $decls.list.grep({ .^name ~~ /VarDeclaration/ }).elems >= 1,
		'variable-declaration matches declaration nodes';

	my $assigns = $ast.&ast-query('.assignment');
	my @kinds = $assigns.list.map(*.^name).unique;
	ok @kinds.grep(*.ends-with('Assignment')).elems || @kinds.grep(*.contains('Initializer::Assign')).elems,
		'assignment group matches assignment-like nodes';
}

# --- #id mapping coverage ---
{
	my $ast = q:to/END/.AST;
		my $x = 1;
		$x = 2;
		sub foo() { }
		class MyClass { }
		grammar G { token tok { \d+ } }
		say :key;
		my %h = a => 1;
	END

	# Calls: .call#say
	ok $ast.&ast-query('.call#say').list.elems >= 1, 'call#say matches Call by name';

	# Variables: usages and declarations
	ok $ast.&ast-query('.variable-usage#x').list.elems >= 1, 'variable-usage#x matches variable usages';
	ok $ast.&ast-query('.variable-declaration#x').list.elems >= 1, 'variable-declaration#x matches var decls';

	# Routines and packages
	ok $ast.&ast-query('RakuAST::Sub#foo').list.elems >= 1, 'Sub#foo matches sub by name';
	ok $ast.&ast-query('RakuAST::Class#MyClass').list.elems >= 1, 'Class#MyClass matches class by name';

	# Regex declaration
	ok $ast.&ast-query('RakuAST::TokenDeclaration#tok').list.elems >= 1, 'TokenDeclaration#tok matches token';

	# Pairs
	ok $ast.&ast-query('RakuAST::ColonPair#key').list.elems >= 1, 'ColonPair#key matches :key';
	ok $ast.&ast-query('RakuAST::FatArrow#a').list.elems >= 1, 'FatArrow#a matches a => 1';
}

done-testing
