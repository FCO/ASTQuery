use experimental :rakuast;
use Test;
use ASTQuery;

plan 10; # Comprehensive query syntax tests with manual node validation

# Helper function to manually walk AST tree and collect all nodes of specific types
sub walk-ast-manual($ast, &condition --> Array) {
    my @results = Empty;
    
    # Check current node
    @results.push($ast) if condition($ast);
    
    # Manually traverse child nodes based on known RakuAST structure
    # Different node types have different child access patterns
    
    # Try common traversal patterns for different node types
    if $ast.^can('statements') && $ast.statements.defined {
        for $ast.statements -> $stmt {
            @results.append: walk-ast-manual($stmt, &condition);
        }
    }
    
    if $ast.^can('expression') && $ast.expression.defined {
        @results.append: walk-ast-manual($ast.expression, &condition);
    }
    
    if $ast.^can('args') && $ast.args.defined {
        @results.append: walk-ast-manual($ast.args, &condition);
    }
    
    if $ast.^can('body') && $ast.body.defined {
        @results.append: walk-ast-manual($ast.body, &condition);
    }
    
    if $ast.^can('then') && $ast.then.defined {
        @results.append: walk-ast-manual($ast.then, &condition);
    }
    
    if $ast.^can('source') && $ast.source.defined {
        @results.append: walk-ast-manual($ast.source, &condition);
    }
    
    if $ast.^can('left') && $ast.left.defined {
        @results.append: walk-ast-manual($ast.left, &condition);
    }
    
    if $ast.^can('right') && $ast.right.defined {
        @results.append: walk-ast-manual($ast.right, &condition);
    }
    
    if $ast.^can('condition') && $ast.condition.defined {
        @results.append: walk-ast-manual($ast.condition, &condition);
    }
    
    if $ast.^can('name') && $ast.name.defined && $ast.name ~~ RakuAST::Node {
        @results.append: walk-ast-manual($ast.name, &condition);
    }
    
    if $ast.^can('signature') && $ast.signature.defined {
        @results.append: walk-ast-manual($ast.signature, &condition);
    }
    
    if $ast.^can('parameters') && $ast.parameters.defined {
        for $ast.parameters -> $param {
            @results.append: walk-ast-manual($param, &condition);
        }
    }
    
    return @results;
}

# Test case 1: Basic .literal group query
subtest "Basic literal group query", {
    plan 1;
    
    # Input: Define a known code sample
    my $code = q{my $x = 42; my $name = "hello"; my $flag = True;};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find all literal nodes by hand
    my @expected-literals = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::IntLiteral | RakuAST::StrLiteral | RakuAST::Literal
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('.literal');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-literals.sort,
        ".literal query returns exactly the manually identified literal nodes";
};

# Test case 2: Integer group query
subtest "Integer group query", {
    plan 1;
    
    # Input: Define a known code sample with integers
    my $code = q{my $a = 42; my $b = 123; say 999;};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find all integer literal nodes by hand
    my @expected-ints = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::IntLiteral
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('.int');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-ints.sort,
        ".int query returns exactly the manually identified integer literal nodes";
};

# Test case 3: String group query  
subtest "String group query", {
    plan 1;
    
    # Input: Define a known code sample with strings
    my $code = q{my $name = "hello"; say "world"; my $path = "test.txt";};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find all string literal nodes by hand
    my @expected-strings = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::StrLiteral
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('.str');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-strings.sort,
        ".str query returns exactly the manually identified string literal nodes";
};

# Test case 4: Variable group query
subtest "Variable group query", {
    plan 1;
    
    # Input: Define a known code sample with variables
    my $code = q{my $x = 10; my $name = "test"; $x + 5;};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find all variable nodes by hand
    my @expected-vars = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::Var | RakuAST::Var::Lexical | RakuAST::VarDeclaration
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('.var');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-vars.sort,
        ".var query returns exactly the manually identified variable nodes";
};

# Test case 5: ID query with specific integer value
subtest "ID query for specific integer value", {
    plan 1;
    
    # Input: Define a known code sample with specific integer 42
    my $code = q{my $x = 42; my $y = 123; say 42;};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find nodes with value 42 by hand
    my @expected-42s = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::IntLiteral && $node.can('value') && $node.value == 42
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('#42');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-42s.sort,
        "#42 query returns exactly the manually identified nodes with value 42";
};

# Test case 6: ID query with specific string value
subtest "ID query for specific string value", {
    plan 1;
    
    # Input: Define a known code sample with specific string "hello"
    my $code = q{my $name = "hello"; say "world"; print "hello";};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find nodes with value "hello" by hand
    my @expected-hellos = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::StrLiteral && $node.can('value') && $node.value eq "hello"
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('#"hello"');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-hellos.sort,
        '#"hello" query returns exactly the manually identified nodes with value "hello"';
};

# Test case 7: Combined group and ID query
subtest "Combined group and ID query", {
    plan 1;
    
    # Input: Define a known code sample with integer 42
    my $code = q{my $x = 42; my $name = "hello"; say 42;};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find integer nodes with value 42 by hand
    my @expected-int-42s = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::IntLiteral && $node.can('value') && $node.value == 42
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('.int#42');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-int-42s.sort,
        ".int#42 query returns exactly the manually identified integer nodes with value 42";
};

# Test case 8: Descendant query (child relationships)
subtest "Descendant query", {
    plan 1;
    
    # Input: Define a known code sample with conditionals containing calls
    my $code = q{if True { say "hello"; print "world"; }};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find all conditionals first, then find calls inside them by hand
    my @expected-calls-in-conditionals = Empty;
    my @conditionals = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::Statement::If | RakuAST::Statement::Unless | RakuAST::Statement::When
    });
    
    for @conditionals -> $conditional {
        my @calls-in-this-conditional = walk-ast-manual($conditional, -> $node {
            $node ~~ RakuAST::Call
        });
        @expected-calls-in-conditionals.append: @calls-in-this-conditional;
    }
    
    # Query using the system under test
    my $result = $ast.&ast-query('.conditional >>> .call');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-calls-in-conditionals.sort,
        ".conditional >>> .call returns exactly the manually identified call nodes inside conditionals";
};

# Test case 9: Named capture query
subtest "Named capture query", {
    plan 2;
    
    # Input: Define a known code sample with literals
    my $code = q{my $a = 42; my $b = "test"; my $c = 123;};
    my $ast = $code.AST;
    
    # Manual AST traversal: Find all literal nodes by hand
    my @expected-literals = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::IntLiteral | RakuAST::StrLiteral | RakuAST::Literal
    });
    
    # Query using the system under test
    my $result = $ast.&ast-query('.literal$numbers');
    
    # Validate that query captures work correctly
    ok $result.hash<numbers>:exists, "Named capture 'numbers' exists for literals";
    is-deeply $result.hash<numbers>.sort, @expected-literals.sort,
        "Named capture 'numbers' contains exactly the manually identified literal nodes";
};

# Test case 10: Complex nested query
subtest "Complex nested query", {
    plan 1;
    
    # Input: Define a known code sample with nested structures
    my $code = q{
        if True {
            for 1..3 -> $i {
                say $i;
            }
        }
    };
    my $ast = $code.AST;
    
    # Manual AST traversal: Find conditionals, then iterables inside them, then calls inside those
    my @expected-calls-in-iterables-in-conditionals = Empty;
    my @conditionals = walk-ast-manual($ast, -> $node {
        $node ~~ RakuAST::Statement::If | RakuAST::Statement::Unless | RakuAST::Statement::When
    });
    
    for @conditionals -> $conditional {
        my @iterables-in-conditional = walk-ast-manual($conditional, -> $node {
            $node ~~ RakuAST::Statement::For | RakuAST::Statement::Loop | RakuAST::ForLoopImplementation
        });
        
        for @iterables-in-conditional -> $iterable {
            my @calls-in-iterable = walk-ast-manual($iterable, -> $node {
                $node ~~ RakuAST::Call
            });
            @expected-calls-in-iterables-in-conditionals.append: @calls-in-iterable;
        }
    }
    
    # Query using the system under test
    my $result = $ast.&ast-query('.conditional >>> .iterable >>> .call');
    
    # Validate that query returns exactly the manually found nodes
    is-deeply $result.list.sort, @expected-calls-in-iterables-in-conditionals.sort,
        ".conditional >>> .iterable >>> .call returns exactly the manually identified call nodes inside iterables inside conditionals";
};

done-testing;