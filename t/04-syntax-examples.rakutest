use experimental :rakuast;
use ASTQuery;
use ASTQuery::Matcher;
use Test;

# Tests for all syntax examples documented in .github/copilot-instructions.md
# This ensures all documented query patterns are actually functional

# Basic node type matching - already tested in other files, but including for completeness
subtest 'Basic node type matching' => {
    # '.int' - Find IntLiteral nodes
    my $ast = "42".AST;
    my $result = ast-query($ast, ".int");
    isa-ok $result.list[0], RakuAST::IntLiteral, "'.int' matches IntLiteral nodes";
    is $result.list[0].value, 42, "Found correct IntLiteral value";

    # 'RakuAST::Call' - Find Call nodes by full class name  
    my $call-ast = "say 42".AST;
    my $call-result = ast-query($call-ast, "RakuAST::Call");
    ok $call-result.list.elems > 0, "'RakuAST::Call' finds Call nodes";
    isa-ok $call-result.list[0], RakuAST::Call, "Found Call node by full class name";
}

# Attribute matching 
subtest 'Attribute matching' => {
    # '.int[value=42]' - Find IntLiteral with value 42
    my $ast = "42, 13, 3".AST;
    my $result = ast-query($ast, ".int[value=42]");
    is $result.list.elems, 1, "'.int[value=42]' finds exactly one match";
    is $result.list[0].value, 42, "Found IntLiteral with correct value";

    # '.call[name]' - Find Call nodes that have a name attribute
    my $call-ast = "say 42".AST;
    my $call-result = ast-query($call-ast, ".call[name]");
    ok $call-result.list.elems > 0, "'.call[name]' finds Call nodes with name attribute";
    ok $call-result.list[0].?name.defined, "Found Call node has name attribute";
}

# ID matching (specific attribute values)
subtest 'ID matching' => {
    # '#42' - Find nodes with value/identifier of 42
    my $ast = "42, 13, 3".AST;
    my $result = ast-query($ast, "#42");
    is $result.list.elems, 1, "'#42' finds exactly one match";
    is $result.list[0].value, 42, "ID matching finds correct value";
}

# Relationship operators - the main focus of these new tests
subtest 'Relationship operators' => {
    # Create a more complex AST for relationship testing
    my $complex-ast = "say(42 + 13)".AST;

    # '.call > .int' - Call nodes with IntLiteral children (direct children only)
    my $direct-child = ast-query($complex-ast, ".call > .int");
    # This might not match because the int literals are nested deeper in an ApplyInfix
    # But it tests the direct child operator
    
    # '.call >> .int' - Call nodes with IntLiteral descendants (skipping ignorable nodes)
    my $gchild-result = ast-query($complex-ast, ".call >> .int");
    ok $gchild-result.list.elems > 0, "'.call >> .int' finds Call with IntLiteral descendants";

    # '.call >>> .int' - Call nodes with IntLiteral descendants (any depth)
    my $any-desc = ast-query($complex-ast, ".call >>> .int");
    ok $any-desc.list.elems > 0, "'.call >>> .int' finds Call with IntLiteral at any depth";

    # '.int < .call' - IntLiteral nodes with Call parents
    my $parent-result = ast-query($complex-ast, ".int < .call");
    # This tests the parent relationship operator

    # '.int << .call' - IntLiteral nodes with Call ancestors (skipping ignorable)
    my $gparent-result = ast-query($complex-ast, ".int << .call");
    ok $gparent-result.list.elems > 0, "'.int << .call' finds IntLiterals with Call ancestors";

    # '.int <<< .call' - IntLiteral nodes with Call ancestors (any depth)
    my $any-anc = ast-query($complex-ast, ".int <<< .call");
    ok $any-anc.list.elems > 0, "'.int <<< .call' finds IntLiterals with Call ancestors at any depth";
}

# Named captures
subtest 'Named captures' => {
    # '.call$mycall' - Capture Call nodes as 'mycall'
    my $ast = "say 42".AST;
    my $result = ast-query($ast, ".call\$mycall");
    ok $result.hash<mycall>.defined, "'.call\$mycall' creates named capture";
    isa-ok $result.hash<mycall>[0], RakuAST::Call, "Named capture contains Call node";

    # '.call >> .int$myint' - Find calls with int descendants, capture ints
    my $desc-capture = ast-query($ast, ".call >> .int\$myint");
    ok $desc-capture.hash<myint>.defined, "'.call >> .int\$myint' creates named capture for descendants";
    isa-ok $desc-capture.hash<myint>[0], RakuAST::IntLiteral, "Named capture contains IntLiteral";
}

# Complex examples from the documentation
subtest 'Complex attribute matching' => {
    # '.apply-op[left=1, right=3]' - ApplyOp nodes with specific operands
    # This requires creating an AST with ApplyInfix/ApplyOp that has these specific values
    my $apply-ast = "1 + 3".AST;
    
    # Note: The exact attribute names might vary based on RakuAST implementation
    # This test validates the multi-attribute matching syntax
    
    # Test basic apply-op matching first
    my $apply-result = ast-query($apply-ast, ".apply-infix");
    ok $apply-result.list.elems > 0, "Can find ApplyInfix nodes";
    
    # Test attribute matching on apply operations
    my $left-test = ast-query($apply-ast, ".apply-infix[left]");
    # Even if specific values don't match, this tests the attribute syntax
}

# Advanced relationship patterns
subtest 'Advanced relationship patterns' => {
    # Create a conditional expression for complex testing
    my $conditional-ast = "if 42 { say 1 } else { say 2 }".AST;
    
    # Test complex descendant patterns
    my $complex-desc = ast-query($conditional-ast, ".conditional >>> .int");
    # This tests finding integers anywhere within a conditional structure
    
    # Test mixed relationship and capture patterns
    my $mixed-result = ast-query($conditional-ast, ".conditional >> .call\$calls");
    # This finds calls within conditionals and captures them
}

# Test edge cases and error handling
subtest 'Edge cases and syntax validation' => {
    # Test empty matches
    my $ast = "42".AST;
    my $no-match = ast-query($ast, ".call"); # Int literal has no calls
    is $no-match.list.elems, 0, "Non-matching query returns empty list";
    
    # Test multiple captures
    my $multi-ast = "say 1; say 2".AST;
    my $multi-capture = ast-query($multi-ast, ".call\$all_calls");
    ok $multi-capture.hash<all_calls>.elems >= 2, "Multiple nodes can be captured";
}

done-testing;