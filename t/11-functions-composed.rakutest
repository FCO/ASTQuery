use experimental :rakuast;
use Test;
use ASTQuery;

# &function combined with attribute traversal on args
{
	my $ast = q:to/CODE/.AST;
		sub f($x) { }
		f 42;
		say 1, 2;
		# extra call removed to avoid undeclared routine
	CODE
	my $res = $ast.&ast-query('&is-call[args=>>>.int]');
	ok $res.list.elems >= 1, '&is-call[args=>>>.int] finds calls with int args';
}

# &function with group requirement
{
	my $ast = q:to/CODE/.AST;
		if 1 %% 2 {
			say 1 * 3;
		}
		say "a" ~ "b";
	CODE
	my $res = $ast.&ast-query('&has-int .apply-operator');
	ok $res.list.elems >= 1, '&has-int .apply-operator matches apply operators with ints';
}

# &function with #id on call name
{
	my $ast = q:to/CODE/.AST;
		say 1;
		sub f($x) { }
		f 1;
	CODE
	my $res = $ast.&ast-query('&is-call#say');
	ok $res.list.elems >= 1, '&is-call#say matches say call(s)';
}

# &function combined with attribute value contains operator on name
{
	my $ast = q:to/CODE/.AST;
		say 1;
		sub foobar($x) { }
		foobar 2;
	CODE
	my $res = $ast.&ast-query('&is-call[name~=bar]');
	ok $res.list.elems >= 1, '&is-call[name~=bar] matches foobar call';
}

# &function used with descendant traversal
{
	my $ast = q:to/CODE/.AST;
		if $_ %% 2 {
			say $_ * 2;
		}
	CODE
	my $res = $ast.&ast-query('&has-int >>> .int');
	ok $res.list.elems >= 1, '&has-int >>> .int finds nodes with int descendant';
}

done-testing;
