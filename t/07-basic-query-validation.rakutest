use experimental :rakuast;
use Test;
use ASTQuery;

plan 15; # Basic query syntax validation tests

# Simple test cases with minimal code samples
# These tests focus on verifying that the query syntax works correctly
# with the most common patterns

subtest "Integer literal queries", {
    plan 3;
    
    my $code = q{my $x = 42;};
    my $ast = $code.AST;
    
    # Test group query for integers
    my $int-result = $ast.&ast-query('.int');
    ok $int-result.list.elems > 0, "Found integers with .int group query";
    ok $int-result.list.grep(*.^name eq "RakuAST::IntLiteral").elems > 0, "Found element is actually an IntLiteral";
    
    # Test ID query for specific value
    my $int42-result = $ast.&ast-query('#42');
    ok $int42-result.list.elems > 0, "Found value 42 with #42 ID query";
    ok $int42-result.list.grep(*.can('value') && *.value == 42).elems > 0, "Found element has correct value 42";
    
    # Test combined group and ID
    my $combined-result = $ast.&ast-query('.int#42');
    ok $combined-result.list.elems > 0, "Found integer 42 with .int#42 combined query";
    ok $combined-result.list.grep(*.can('value') && *.value == 42).elems > 0, "Combined query found correct integer with value 42";
};

subtest "String literal queries", {
    plan 3;
    
    my $code = q{my $name = "hello";};
    my $ast = $code.AST;
    
    # Test group query for strings
    my $str-result = $ast.&ast-query('.str');
    ok $str-result.list.elems > 0, "Found strings with .str group query";
    ok $str-result.list.grep(*.^name eq "RakuAST::StrLiteral").elems > 0, "Found element is actually a StrLiteral";
    
    # Test ID query for specific string
    my $hello-result = $ast.&ast-query('#"hello"');
    ok $hello-result.list.elems > 0, "Found string 'hello' with #\"hello\" ID query";
    ok $hello-result.list.grep(*.can('value') && *.value eq "hello").elems > 0, "Found element has correct value 'hello'";
    
    # Test combined group and ID
    my $combined-result = $ast.&ast-query('.str#"hello"');
    ok $combined-result.list.elems > 0, "Found string 'hello' with .str#\"hello\" combined query";
    ok $combined-result.list.grep(*.can('value') && *.value eq "hello").elems > 0, "Combined query found correct string with value 'hello'";
};

subtest "Variable queries", {
    plan 3;
    
    my $code = q{my $count = 0; $count++;};
    my $ast = $code.AST;
    
    # Test group query for variables
    my $var-result = $ast.&ast-query('.var');
    ok $var-result.list.elems > 0, "Found variables with .var group query";
    ok $var-result.list.grep(*.^name ~~ /Var/).elems > 0, "Found element is actually a variable type";
    
    # Test ID query for specific variable name
    my $count-result = $ast.&ast-query('#count');
    ok $count-result.list.elems > 0, "Found variable 'count' with #count ID query";
    ok $count-result.list.grep(*.can('desigilname') && *.desigilname eq "count").elems > 0, "Found element has correct variable name 'count'";
    
    # Test combined group and ID
    my $combined-result = $ast.&ast-query('.var#count');
    ok $combined-result.list.elems > 0, "Found variable 'count' with .var#count combined query";
    ok $combined-result.list.grep(*.can('desigilname') && *.desigilname eq "count").elems > 0, "Combined query found correct variable with name 'count'";
};

subtest "Function call queries", {
    plan 3;
    
    my $code = q{say "hello"; print "world";};
    my $ast = $code.AST;
    
    # Test group query for calls
    my $call-result = $ast.&ast-query('.call');
    ok $call-result.list.elems > 0, "Found calls with .call group query";
    ok $call-result.list.grep(*.^name eq "RakuAST::Call").elems > 0, "Found element is actually a Call";
    
    # Test ID query for specific function name
    my $say-result = $ast.&ast-query('#say');
    ok $say-result.list.elems > 0, "Found 'say' call with #say ID query";
    ok $say-result.list.grep(*.can('name') && *.name.can('simple-identifier') && *.name.simple-identifier eq "say").elems > 0, "Found element has correct name 'say'";
    
    # Test combined group and ID
    my $combined-result = $ast.&ast-query('.call#say');
    ok $combined-result.list.elems > 0, "Found 'say' call with .call#say combined query";
    ok $combined-result.list.grep(*.can('name') && *.name.can('simple-identifier') && *.name.simple-identifier eq "say").elems > 0, "Combined query found correct call with name 'say'";
};

subtest "Conditional queries", {
    plan 3;
    
    my $code = q{if True { say "yes"; }};
    my $ast = $code.AST;
    
    # Test group query for conditionals
    my $cond-result = $ast.&ast-query('.conditional');
    ok $cond-result.list.elems > 0, "Found conditionals with .conditional group query";
    ok $cond-result.list.grep(*.^name ~~ /If|Unless|When|With/).elems > 0, "Found element is actually a conditional type";
    
    # Test descendant query to find calls inside conditionals
    my $cond-call-result = $ast.&ast-query('.conditional >>> .call');
    ok $cond-call-result.list.elems > 0, "Found calls inside conditionals with .conditional >>> .call";
    ok $cond-call-result.list.grep(*.^name eq "RakuAST::Call").elems > 0, "Found element is actually a call inside a conditional";
    
    # Test descendant query with ID
    my $cond-say-result = $ast.&ast-query('.conditional >>> #say');
    ok $cond-say-result.list.elems > 0, "Found 'say' inside conditionals with .conditional >>> #say";
    ok $cond-say-result.list.grep(*.can('name') && *.name.can('simple-identifier') && *.name.simple-identifier eq "say").elems > 0, "Found element is specifically a 'say' call inside a conditional";
};

subtest "Loop queries", {
    plan 3;
    
    my $code = q{for 1..3 -> $i { say $i; }};
    my $ast = $code.AST;
    
    # Test group query for loops
    my $loop-result = $ast.&ast-query('.iterable');
    ok $loop-result.list.elems > 0, "Found loops with .iterable group query";
    ok $loop-result.list.grep(*.^name ~~ /For|Loop|While/).elems > 0, "Found element is actually an iterable type";
    
    # Test descendant query to find calls inside loops
    my $loop-call-result = $ast.&ast-query('.iterable >>> .call');
    ok $loop-call-result.list.elems > 0, "Found calls inside loops with .iterable >>> .call";
    ok $loop-call-result.list.grep(*.^name eq "RakuAST::Call").elems > 0, "Found element is actually a call inside a loop";
    
    # Test descendant query for variables inside loops
    my $loop-var-result = $ast.&ast-query('.iterable >>> .var');
    ok $loop-var-result.list.elems > 0, "Found variables inside loops with .iterable >>> .var";
    ok $loop-var-result.list.grep(*.^name ~~ /Var/).elems > 0, "Found element is actually a variable inside a loop";
};

subtest "Declaration queries", {
    plan 3;
    
    my $code = q{sub process($data) { return $data + 1; }};
    my $ast = $code.AST;
    
    # Test group query for declarations
    my $decl-result = $ast.&ast-query('.declaration');
    ok $decl-result.list.elems > 0, "Found declarations with .declaration group query";
    ok $decl-result.list.grep(*.^name ~~ /Declaration/).elems > 0, "Found element is actually a declaration type";
    
    # Test ID query for specific routine name
    my $process-result = $ast.&ast-query('#process');
    ok $process-result.list.elems > 0, "Found 'process' routine with #process ID query";
    ok $process-result.list.grep(*.can('name') && *.name.can('simple-identifier') && *.name.simple-identifier eq "process").elems > 0, "Found element has correct name 'process'";
    
    # Test combined group and ID
    my $combined-result = $ast.&ast-query('.declaration#process');
    ok $combined-result.list.elems > 0, "Found 'process' declaration with .declaration#process combined query";
    ok $combined-result.list.grep(*.can('name') && *.name.can('simple-identifier') && *.name.simple-identifier eq "process").elems > 0, "Combined query found correct declaration with name 'process'";
};

subtest "Parameter queries", {
    plan 2;
    
    my $code = q{sub calculate($x, $y) { $x + $y; }};
    my $ast = $code.AST;
    
    # Test group query for parameters
    my $param-result = $ast.&ast-query('.parameter');
    ok $param-result.list.elems > 0, "Found parameters with .parameter group query";
    ok $param-result.list.grep(*.^name ~~ /Parameter/).elems > 0, "Found element is actually a parameter type";
    
    # Test descendant query for parameters inside declarations
    my $decl-param-result = $ast.&ast-query('.declaration >>> .parameter');
    ok $decl-param-result.list.elems > 0, "Found parameters inside declarations with .declaration >>> .parameter";
    ok $decl-param-result.list.grep(*.^name ~~ /Parameter/).elems > 0, "Found element is actually a parameter inside a declaration";
};

subtest "Operator queries", {
    plan 2;
    
    my $code = q{my $result = $x + $y * 2;};
    my $ast = $code.AST;
    
    # Test group query for applied operators
    my $apply-op-result = $ast.&ast-query('.apply-op');
    ok $apply-op-result.list.elems > 0, "Found applied operators with .apply-op group query";
    ok $apply-op-result.list.grep(*.^name ~~ /ApplyOp|ApplyInfix|ApplyPrefix|ApplyPostfix/).elems > 0, "Found element is actually an applied operator";
    
    # Test group query for all operators
    my $op-result = $ast.&ast-query('.op');
    ok $op-result.list.elems > 0, "Found operators with .op group query";
    ok $op-result.list.grep(*.^name ~~ /Op|Infix|Prefix|Postfix/).elems > 0, "Found element is actually an operator";
};

subtest "Named capture queries", {
    plan 2;
    
    my $code = q{my $a = 1; my $b = 2; my $c = 3;};
    my $ast = $code.AST;
    
    # Test named capture for literals
    my $lit-capture-result = $ast.&ast-query('.literal$numbers');
    ok $lit-capture-result.hash<numbers>:exists, "Named capture 'numbers' exists for literals";
    ok $lit-capture-result.hash<numbers>.elems > 0, "Named capture 'numbers' contains elements";
    ok $lit-capture-result.hash<numbers>.grep(*.^name ~~ /Literal/).elems > 0, "Captured elements are actually literals";
};

subtest "Complex descendant queries", {
    plan 3;
    
    my $code = q{
        if $condition {
            for @items -> $item {
                say $item.name;
            }
        }
    };
    my $ast = $code.AST;
    
    # Test nested descendant queries
    my $complex1-result = $ast.&ast-query('.conditional >>> .iterable');
    ok $complex1-result.list.elems >= 0, "Found loops inside conditionals with .conditional >>> .iterable";
    if $complex1-result.list.elems > 0 {
        ok $complex1-result.list.grep(*.^name ~~ /For|Loop|While/).elems > 0, "Found element is actually an iterable inside a conditional";
    } else {
        pass "No loops inside conditionals found (acceptable)";
    }
    
    # Test triple descendant query
    my $complex2-result = $ast.&ast-query('.conditional >>> .iterable >>> .call');
    ok $complex2-result.list.elems >= 0, "Found calls inside loops inside conditionals";
    if $complex2-result.list.elems > 0 {
        ok $complex2-result.list.grep(*.^name eq "RakuAST::Call").elems > 0, "Found element is actually a call inside loops inside conditionals";
    } else {
        pass "No calls inside loops inside conditionals found (acceptable)";
    }
    
    # Test descendant with ID
    my $complex3-result = $ast.&ast-query('.conditional >>> .iterable >>> #say');
    ok $complex3-result.list.elems >= 0, "Found 'say' calls inside loops inside conditionals";
    if $complex3-result.list.elems > 0 {
        ok $complex3-result.list.grep(*.can('name') && *.name.can('simple-identifier') && *.name.simple-identifier eq "say").elems > 0, "Found element is specifically a 'say' call inside loops inside conditionals";
    } else {
        pass "No 'say' calls inside loops inside conditionals found (acceptable)";
    }
};

subtest "Child relationship queries", {
    plan 2;
    
    my $code = q{if True { say "direct"; }};
    my $ast = $code.AST;
    
    # Test direct child queries
    my $child-result = $ast.&ast-query('.conditional > .statement');
    ok $child-result.list.elems >= 0, "Direct child query .conditional > .statement executed";
    if $child-result.list.elems > 0 {
        ok $child-result.list.grep(*.^name ~~ /Statement/).elems > 0, "Found element is actually a statement directly under conditional";
    } else {
        pass "No direct statement children found (acceptable)";
    }
    
    # Test grandchild queries  
    my $grandchild-result = $ast.&ast-query('.conditional >> .call');
    ok $grandchild-result.list.elems >= 0, "Grandchild query .conditional >> .call executed";
    if $grandchild-result.list.elems > 0 {
        ok $grandchild-result.list.grep(*.^name eq "RakuAST::Call").elems > 0, "Found element is actually a call as grandchild of conditional";
    } else {
        pass "No grandchild calls found (acceptable)";
    }
};

subtest "Attribute-based queries", {
    plan 3;
    
    my $code = q{my $value = 42; say "hello";};
    my $ast = $code.AST;
    
    # Test attribute existence
    my $value-attr-result = $ast.&ast-query('[value]');
    ok $value-attr-result.list.elems >= 0, "Attribute query [value] executed";
    if $value-attr-result.list.elems > 0 {
        ok $value-attr-result.list.grep(*.can('value')).elems > 0, "Found element actually has a value attribute";
    } else {
        pass "No elements with value attribute found (acceptable)";
    }
    
    # Test specific attribute value
    my $value42-attr-result = $ast.&ast-query('[value=42]');
    ok $value42-attr-result.list.elems >= 0, "Specific attribute query [value=42] executed";
    if $value42-attr-result.list.elems > 0 {
        ok $value42-attr-result.list.grep(*.can('value') && *.value == 42).elems > 0, "Found element actually has value 42";
    } else {
        pass "No elements with value=42 found (acceptable)";
    }
    
    # Test name attribute
    my $name-attr-result = $ast.&ast-query('[name]');
    ok $name-attr-result.list.elems >= 0, "Attribute query [name] executed";
    if $name-attr-result.list.elems > 0 {
        ok $name-attr-result.list.grep(*.can('name')).elems > 0, "Found element actually has a name attribute";
    } else {
        pass "No elements with name attribute found (acceptable)";
    }
};

subtest "Combination syntax queries", {
    plan 3;
    
    my $code = q{
        sub test($input) {
            my $result = $input * 2;
            if $result > 10 {
                return $result;
            }
            return 0;
        }
    };
    my $ast = $code.AST;
    
    # Test multiple groups combined
    my $multi-group-result = $ast.&ast-query('.declaration >>> .conditional >>> .literal');
    ok $multi-group-result.list.elems >= 0, "Multi-group query executed";
    if $multi-group-result.list.elems > 0 {
        ok $multi-group-result.list.grep(*.^name ~~ /Literal/).elems > 0, "Found element is actually a literal inside conditionals inside declarations";
    } else {
        pass "No literals inside conditionals inside declarations found (acceptable)";
    }
    
    # Test group with ID and descendant
    my $group-id-desc-result = $ast.&ast-query('.declaration#test >>> .var#result');
    ok $group-id-desc-result.list.elems >= 0, "Group with ID and descendant query executed";
    if $group-id-desc-result.list.elems > 0 {
        ok $group-id-desc-result.list.grep(*.can('desigilname') && *.desigilname eq "result").elems > 0, "Found element is actually variable 'result' inside 'test' declaration";
    } else {
        pass "No variable 'result' inside 'test' declaration found (acceptable)";
    }
    
    # Test complex capture
    my $complex-capture-result = $ast.&ast-query('.declaration#test >>> .literal$values');
    ok $complex-capture-result.list.elems >= 0, "Complex capture query executed";
    if $complex-capture-result.list.elems > 0 {
        ok $complex-capture-result.list.grep(*.^name ~~ /Literal/).elems > 0, "Found element is actually a literal inside 'test' declaration";
    } else {
        pass "No literals inside 'test' declaration found (acceptable)";
    }
};

subtest "Error handling and edge cases", {
    plan 3;
    
    my $code = q{my $x = 1;};
    my $ast = $code.AST;
    
    # Test query for non-existent group
    my $nonexistent-result = $ast.&ast-query('.nonexistent');
    is $nonexistent-result.list.elems, 0, "Non-existent group returns empty result";
    
    # Test query for non-existent ID
    my $nonexistent-id-result = $ast.&ast-query('#nonexistent');
    is $nonexistent-id-result.list.elems, 0, "Non-existent ID returns empty result";
    
    # Test complex query with non-matches
    my $no-match-result = $ast.&ast-query('.conditional >>> .call');
    is $no-match-result.list.elems, 0, "Query with no matches returns empty result";
};

done-testing;